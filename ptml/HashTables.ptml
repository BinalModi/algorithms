<html>
    <head>
        <link href="style.css" rel="stylesheet" type="text/css"/>
        <title>
            Design and Analysis of Algorithms: Hash Tables
        </title>
    </head>

    <body>
<!--include menu.txt -->
        <h1>
            Design and Analysis of Algorithms: Hash Tables
            <a href="#note1">*</a>
        </h1>
        
        <details>
            <summary class="sum1">
            Dictionaries
            </summary>

            <p>
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e2/English-English_and_English-Persian_dictionaries.JPG/350px-English-English_and_English-Persian_dictionaries.JPG">
            </p>
    
            <details>
                <summary class="sum2">
                Dictionary ADT.
                </summary>
                <p>
                Operations associated with this data type allow:
                <ul>
                    <li>the addition of a pair to the collection
                    </li>
                    <li>the removal of a pair from the collection
                    </li>
                    <li>the modification of an existing pair
                    </li>
                    <li>the lookup of a value associated with a particular key
                    </li>
                </ul>
                    <p>
                    (<a href="https://en.wikipedia.org/wiki/Associative_array">Source</a>)
                    </p>
                </p>
                <p>
                Typical uses:
                <ul>
                    <li> Symbol lookup in a programming language
                    </li>
                    <li> Counting words in a book
                    </li>
                    <li> Store colors by name as key and their numeric equivalent as
                    the value. Then we can write <b>set_text(colors["red"])</b>.
                    </li>
                </ul>
                </p>
        
        
                <p>
                <em>Direct addressing</em> and <em>Hashing</em>
                are two ways of implementing a
                dictionary. Are there others?
                </p>
            </details>
        </details>

        <details>
            <summary class="sum1">
            11.1 Direct-address tables
            </summary>
            <ul>
                <li> <em>O(1)</em> <em>worst</em> case time for lookup.
                </li>
                <li> Uses:
                <ul class="nested">
                    <li> Memoization
                    </li>
                    <li> Bingo
                    </li>
                    <li> Sieve of Eratosthenes
                    </li>
                    <li> Mark zipcodes seen
                    </li>
                </ul>
                </li>
                <li> Downside: wastes space. If you have no idea how many possible
                keys you need, direct addressing is not a good choice.
                <br>For instance, if your key is an arbitrary string!
                </li>
                <li><a
                        href="https://github.com/gcallah/algorithms/blob/master/python/hash.py">
                    Example code here.
                    </a>
                </li>
            </ul>
        </details>

        <details>
            <summary class="sum1">
            11.2 Hash tables
            </summary>
            <figure>
            <img
            src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Hash_table_4_1_1_0_0_1_0_LL.svg/300px-Hash_table_4_1_1_0_0_1_0_LL.svg.png">
            </figure>
    
            <details>
            <summary class="sum2">
            Basic Hashing
            </summary>
            <ul>
                <li> <em>O(1)</em> <em>average</em> case time for lookup.
                </li>
                <li> Universe of keys <em>U</em> mapped into slots of a <em>hash table</em>
                of size <em>m</em> by hash function <em>h</em>.
                </li>
                <li> Because <em>size(U) > m</em>, collisions are always possible.
                <br>Imagine we hash by word length: 'mark' and 'beam' both hash to
                4. (Stupid hash function, but it illustrates the idea.) We must
                resolve this collision somehow.
                </li>
                <li> Resolve collisions by chaining:
                <br> Each slot holds a linked list of values.
                </li>
                <li> <a
                    href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">
                Cryptographic hashing
                </a>
                <br> Use large hash keys:
                    <a href="https://en.wikipedia.org/wiki/SHA-1">
                        SHA-1</a> uses 160 bit keys. <a
                        href="https://en.wikipedia.org/wiki/SHA-2">SHA-2</a> uses
                        keys of up to 512 bits.
                        <br>
                        <img
                        src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/7d/SHA-2.svg/400px-SHA-2.svg.png">
                        <li> <a href="http://www.phash.org">
                            Perceptual hashing
                        </a>
                    </li>
                </li>
            </ul>
            </details>

            <details>
                <summary class="sum2">
                Introducing probability into an algorithm.
                </summary>
                <p>
                What happens to the usual assumptions?
                <br>
                <b>Correctness</b>: always, most of the time?
                <br>
                <b>Termination</b>: always, or almost always?
                What does "performance" mean if the running
                time/answer/even termination change from one run to the next?
                </p>
            </details>

            <details>
                <summary class="sum2">
                Probability Basics
                </summary>
                <p>
                <a href="https://gcallah.github.io/algorithms/Probability.html">
                    Reviewed in this document.
                </a>
                </p>
            </details>

            <details>
                <summary class="sum2">
                Simple uniform hashing 
                </summary>
                <p>
                This employs <b>chaining</b>. Furthermore, we assume that the
                distribution of elements is uniform across hash table slots.
                <br>
                <img
                src="https://upload.wikimedia.org/wikipedia/commons/3/3b/Hasq_hash_chains.png"
                height="210" width="240">
                    <ul>
                        <li> Hash table <em>T</em> with <em>m</em>
                            slots storing <em>n</em> elements.
                        </li>
                        <li> <b>Load factor</b>: <em>&alpha; = n / m</em>
                        <br> <em>&alpha;</em> is the average number of
                        elements stored in a
                        chain.
                        </li>
                        <li> Our analysis is in terms of <em>&alpha;</em>, which can be
                        less than, equal to, or greater than one.
                        </li>
                        <li><b>Worst case</b> is very bad:
                        <br>All <em>n</em> keys hash to the same slot.
                        <br>Worst case for searching becomes <em>&Theta;(n)</em> plus
                        time to compute hash function.
                        <br>We could have just used a linked list directly!
                        </li>
                        <li><b>Average case</b>:
                        <br>Assuming any given element is equally likely to hash into
                        any slot...
                        <br>We get average case <em>&Theta;(1 + &alpha;)</em> time.
                        <br>See proofs in our textbook.
                        </li>
                    </ul>
                </p>
            </details>
        </details>

        <details>
            <summary class="sum1">
            11.3 Hash functions
            </summary>
            <ul>
                <li> First, convert key to an integer.
                <br> E.g., we can interpret characters in a string by their ASCII values.
                <br> Then treat each value as a digit in a radix-128 integer.
                <br>
                (<a
                    href="http://www.drdobbs.com/database/generating-sequential-keys-in-an-arbitra/184409688">
                    See this article for more on radices.</a>)
                </li>
                <li> Keys could be many other things besides strings.
                <br> E.g., genomes:
                <br>
                <img
                src="https://upload.wikimedia.org/wikipedia/commons/6/63/Part_of_DNA_sequence_prototypification_of_complete_genome_of_virus_5418_nucleotides.gif"
                height="320" width="340">
                </li>
                <li> Division method:
                <br>h(k) = k mod P, where <em>P</em> is a
                suitably-chosen prime number.
                </li>
                <li> Multiplication method:
                <br>h(k) = [m (k A mod 1)],
                where 0 < A < 1>.
                </li>
            </ul>

            <details>
                <summary class="sum2">
                Universal hashing
                </summary>
                <ul>
                    <li>Establish a <em>family</em> of hash functions.
                    </li>
                    <li>Choose so that Prob[h(x) = h(y)] &le; 1/m, where m is
                        the size of our hash table.
                    <br>In other words, the hash functions have no more chance of
                    collision than simply randomly choosing to slots between 1 and m.
                    </li>
                    <li>Choose one at random each execution.
                    <br>Tricky: what if we store hash values?
                    </li>
                    <li>Good average case behavior
                    <br>If a "bad" function handles some
                    data once, a "good" one will handle it another time.
                    <br>So a "bad" set of programming variable names one run will turn
                    into a good set the next run.
                    </li>
                </ul>
            </details>
        </details>

        <details>
            <summary class="sum1">
            11.4 Open addressing
            </summary>
            <ul>
                <li>
                All elements are stored directly in the table; no chaining.
                </li>
                <li>
                Linear probing
                <br>Easy: just move along array indices!
                <br>Prone to clustering
                </li>
                <li>
                Quadratic probing
                </li>
                <li><a href="https://en.wikipedia.org/wiki/Double_hashing">
                    Double hashing
                </a>
                <br>Uses two hash functions to search array for key.
                </li>
                <li><a
                        href="https://github.com/gcallah/algorithms/blob/master/hash_tables.py">
                        Source code here</a>.
                </li>
            </ul>
        </details>
        <details>
            <summary class="sum1">
            11.5 Perfect hashing
            </summary>
        </details>

        <details>
            <summary class="sum1">
                Source Code
            </summary>
            <p>
<!--include HashTables_langs.txt -->
            </p>
        </details>


        <details>
            <summary class="sum1">
            Homework
            </summary>

        <ul>
            <li> Devise three possible hash functions. Analyze each for size of hash
            table necessary and possibility of collisions.
            </li>
            <li> Let's say our hash function is <em>h(k) = k mod 11</em> and we resolve
            conflicts with chaining. Analyze what happens if our data values are
            23, 34, 12, 8, 19, 33, 2, 5, 15, 4, 31, 9, 3, 6, 18, 8, 19 and 22.
            <br>What will happen when we look up 19?
            </li>
            <li>Write (pseudo) code to resolve collisions with chaining. 
            </li>
            <li>Consider the following hashing scheme:
                <br>
                <em>h(k) = k mod m</em>
                <br>
                <em>m = 7</em>
                <br>We convert a string into a hashable key by treating it as a
                base-8 number.
                <br>So 'abc', where a = 1, b = 2, and c = 3, is converted to a
                key as follows: 1 * 8<sup>2</sup> + 2 * 8 + 3 = 83.
                <br>In this hashing scheme, what do the strings 'cba' and 'bac'
                hash to?
                <br>Can you write a more general statement about a pattern we
                can detect here? Something along the lines of, "If the table
                size is 2<sup>P</sup> - 1, and strings are interpreted in radix
                2<sup>P</sup>..."
                <br>
                <br>
                <b>Answer:</b>
                <br>
                <br>
                If <em>h(k) = k mod m</em>, where <em>m = 2<sup>P</sup> -
                    1</em>, and <em>k</em> is a character string interpreted in
                radix 2<sup>P</sup>, then all permutations of a given string
                will hash to the same value. So in the example above, 'abc',
                'cba', and 'bac' all hash to the same value.
                <br>
                <br>
                <b>Proof</b>:
                <br>
                <br>
                Assumed (could be proven, but we won't do it here):
                <ol>
                    <li> (x + y) mod z == 
                            (x mod z + y mod z) mod z
                        <br><b>Example:</b> (10 + 12) mod 7 ==
                        (10 mod 7 + 12 mod 7) mod 7
                    </li>
                    <li> (x * y) mod z == 
                            (x mod z) * (y mod z)
                        mod z
                        <br><b>Example:</b> (10 * 12) mod 7 ==
                        (10 mod 7) * (12 mod 7) mod 7
                        <br>(7 * 17 = 119)
                    </li>
                    <li>if x mod z == 1, then x<sup>n</sup> mod z == 1
                        <br><b>Example:</b> 8 mod 7 == 1, and
                        8<sup>2</sup> mod 7 == 1
                        <br>This is a special case of 2!
                    </li>
                </ol>
                <br>
                So, we have:
                <br>
                <br>
                <img src="https://raw.githubusercontent.com/gcallah/algorithms/master/graphics/H3Eq1.gif">
                <br>
                <br>
                <img src="https://raw.githubusercontent.com/gcallah/algorithms/master/graphics/H3Eq2.gif">
                <br>
                <br>
                <img src="https://raw.githubusercontent.com/gcallah/algorithms/master/graphics/H3Eq3.gif">
                <br>
                <br>
                <img
                src="https://raw.githubusercontent.com/gcallah/algorithms/master/graphics/H3Eq4.gif">
                &nbsp;&nbsp;(By 1)
                <br>
                <br>
                <img
                src="https://raw.githubusercontent.com/gcallah/algorithms/master/graphics/H3Eq5.gif">
                &nbsp;&nbsp;(By 2)
                <br>
                <br>
                <img
                src="https://raw.githubusercontent.com/gcallah/algorithms/master/graphics/H3Eq6.gif">
                &nbsp;&nbsp;(By 3)
                <br>
                <br>
                <img
                src="https://raw.githubusercontent.com/gcallah/algorithms/master/graphics/H3Eq7.gif">
            </li>
        </ul>
    </details>

    </body>
<!--include google_analytics.txt -->
</html>
